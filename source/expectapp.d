/+
Author:
    Colin Grogan
    github.com/grogancolin

Description:
        Implementation of the expect tool (http://expect.sourceforge.net/) in D.

License:
        Boost Software License - Version 1.0 - August 17th, 2003

        Permission is hereby granted, free of charge, to any person or organization
        obtaining a copy of the software and accompanying documentation covered by
        this license (the "Software") to use, reproduce, display, distribute,
        execute, and transmit the Software, and to prepare derivative works of the
        Software, and to permit third-parties to whom the Software is furnished to
        do so, all subject to the following:

        The copyright notices in the Software and this entire statement, including
        the above license grant, this restriction and the following disclaimer,
        must be included in all copies of the Software, in whole or in part, and
        all derivative works of the Software, unless such copies or derivative
        works are solely in the form of machine-executable object code generated by
        a source language processor.

        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
        SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
        FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
        ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
        DEALINGS IN THE SOFTWARE.
+/

module expectapp;


version(DExpectMain){
	import docopt;
	import std.stdio;
	import dexpect;
	import pegged.grammar;
	import std.string;
	import std.file;
	import std.algorithm;

version(Windows){
	enum isWindows=true;
	enum isLinux=false;
	enum os="win";
}
version(Posix){
	enum isWindows=false;
	enum isLinux=true;
	enum os="linux";
}

/// Usage string for docopt
	const string doc =
"dexpect
Usage:
    dexpect [-h] <file>
Options:
    -h --help    Show this message
";
	string[string] customVariables;
	int main(string[] args){

		auto arguments = docopt.docopt(doc, args[1..$], true, "dexpect 0.0.1");
		writeln(arguments);

		File expectScript = File(arguments["<file>"].toString, "r");
		auto parsedScript = ExpectScript(arguments["<file>"].toString.readText);

		// TDOO: Remove these asserts in favor of proper error messages
		assert(parsedScript.name=="ExpectScript");
		// ensure there is a "Script" element
		assert(parsedScript.children.length == 1);
		assert(parsedScript.children[0].name == "ExpectScript.Script");
		auto script = parsedScript.children[0];

		Expect expect;
		string[string] variables;
		// Helper functions for handling each type of command
		void handleSet(ParseTree p){
			if(p.children.length != 2) throw new ExpectScriptParseException("Error parsing Set");
			string name = p.children[0].children[0].matches[0]; //Set.SetName.VerName
			string value="";
			foreach(child; p.children[1].children){//p.children[1] == Set.SetVal
				switch(child.name){
					case "ExpectScript.Variable":
						if(!variables.keys.canFind(child.matches[0])) throw new ExpectScriptParseException("Undefined variable");
						value ~= variables[child.matches[0]];
						break;
					case "ExpectScript.String":
						value ~= child.matches[0];
						break;
					default: break;
				}
			}
			variables[name] = value;
		}

		void handleSpawn(ParseTree p){
			if(p.children.length != 1) throw new ExpectScriptParseException("Error parsing Spawn. ");

			string toSpawn="";
			foreach(child; p.children[0].children){
				switch(child.name){
					case "ExpectScript.Variable":
						if(!variables.keys.canFind(child.matches[0])) throw new ExpectScriptParseException("Undefined variable");
						toSpawn ~= variables[child.matches[0]];
						break;
					case "ExpectScript.String":
						toSpawn ~= child.matches[0];
						break;
					default: writefln("Error - %s", p); break;
				}
			}
			expect = new Expect(toSpawn);

		}

		void handleExpect(ParseTree p){
			if(p.children.length != 1) throw new ExpectScriptParseException("Error parsing Expect");

			if(expect is null)
				throw new ExpectException("Cannot expect before spawning");

			string toExpect="";
			foreach(child; p.children[0].children){
				switch(child.name){
					case "ExpectScript.Variable":
						if(!variables.keys.canFind(child.matches[0])) throw new ExpectScriptParseException("Undefined variable");
						toExpect ~= variables[child.matches[0]];
						break;
					case "ExpectScript.String":
						toExpect ~= child.matches[0];
						break;
					default: break;
				}
			}
			expect.expect(toExpect);
		}

		void handleSend(ParseTree p){
			if(p.children.length != 1) throw new ExpectScriptParseException("Error parsing Send");
			if(expect is null)
				throw new ExpectException("Cannot send data before spawning");

			string toSend="";
			foreach(child; p.children[0].children){
				switch(child.name){
					case "ExpectScript.Variable":
						if(!variables.keys.canFind(child.matches[0])) throw new ExpectScriptParseException("Undefined variable");
						toSend ~= variables[child.matches[0]];
						break;
					case "ExpectScript.String":
						toSend ~= child.matches[0];
						break;
					default: break;
				}
			}
			expect.sendLine(toSend);
		}

		// Process the parse tree!
		script.children
			.filter!(a => // tests if a parse tree has an Attribute tag, and then checks if that attribute matches this os
						  // TODO: Will need to improve this once(if) more attributes are supported
						  a.children[0].name != "ExpectScript.Attributes" ||
						  a.children[0].matches[0] == os )
			.map!(	 a => // strip out the attributes parse tree as we now dont need it
					 a.children[0].name == "ExpectScript.Attributes" ?
					 a.children[1] : a.children[0])
			.each!( (a) { // every remaining parse tree is a Set/Spawn/Expect/Send. Deal with each accordingly
					switch(a.name){
						case "ExpectScript.Set": handleSet(a); break;
						case "ExpectScript.Spawn" : handleSpawn(a); break;
						case "ExpectScript.Expect" : handleExpect(a); break;
						case "ExpectScript.Send" : handleSend(a); break;
						default: break;
					}
				});
		writefln("%s", variables);
		return 0;
	}

mixin(grammar(scriptGrammar));

/// Grammar to be parsed by pegged
/// Potentially full of bugs
enum scriptGrammar = `
ExpectScript:

	# This handles reading in expect script files.
	# Lots to add to this, but will work for simple files

	Script      	<- (EmptyLine / Command)+ :eoi
	Command     	<- :Spacing* Attributes* :Spacing* (
						Comment
						/ Set
						/ Expect
						/ Spawn
						/ Send
				       ) :Spacing* :endOfLine*

	Attributes		<- (VersionWin / VersionLinux)

	VersionWin    	<- "win"
	VersionLinux 	<- "linux"

	Comment			<: :"#" (!eoi !endOfLine .)+ :endOfLine

	Set				<- :"set" :Spacing (!eoi !endOfLine !Equals) SetName :Equals SetVal
	SetName			<- ~VarName
	SetVal			<- ( ~Variable / ~String ) (:Spacing* :'~' :Spacing? (~Variable / ~String))*

	Expect			<- :"expect" :Spacing ToExpect
	ToExpect		<- (~Variable / ~String) (:Spacing* :'~' :Spacing? (~Variable / ~String))*

	Spawn			<- :"spawn" :Spacing ToSpawn
	ToSpawn			<- (~Variable / ~String) (:Spacing* :'~' :Spacing? (~Variable / ~String))*

	Send			<- :"send" :Spacing ToSend
	ToSend			<- (~Variable / ~String) (:Spacing* :'~' :Spacing? (~Variable / ~String))*

	Variable    	<- :"$(" VarName :")"
	VarName     	<- (!eoi !endOfLine !')' !'(' !'$' !Equals .)+

	Text        <- (!eoi !endOfLine !'~' .)+
	DoubleQuoteText <- :doublequote (!eoi !endOfLine !doublequote .)+ :doublequote
	SingleQuoteText <- :"'" (!eoi !endOfLine !"'" .)+ :"'"
	String		<- (
					~DoubleQuoteText /
					~SingleQuoteText /
					~Text
				   )
	Concat		<- (:Spacing* :'~' :Spacing? (~Variable / ~String))
	EmptyLine   <: ('\n\r' / '\n')+
	Equals		<- '='
`;

/+ --------------- Utils --------------- +/
/**
  * Exceptions thrown during expecting data.
  */
class ExpectScriptParseException : Exception {
	this(string message, string file = __FILE__, size_t line = __LINE__, Throwable next = null){
		super(message, file, line, next);
	}
}

}
else{}

